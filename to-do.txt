Bugs
----

* BUGs 4/2025:

        * 'range()' (no args) causes segmentation fault instead of error.
        * keyword for_each loop breaks if a new var is declared inside.
        * ``(range(x)).foreach(y);`` works but ``range(x).foreach(y);``
          does not, though both should behave the same.
        * Closures do not work inside of .foreach callbacks.
        * TTY mode parses all-around unreliably, even though
          script mode seems to work just fine.
        * there's a VAR_INCR/DECR_REF imbalance somewhere, preventing
          some vars from getting deleted when they should.
        * Broke static typing.  This was intentional to get rid of the
          qop_mov way of assignment, but now it needs to be fixed.

Must Do
-------

* ``this`` keyword barely tested; it will probably break a lot of
  stuff that seems to work without it.

* Change ``load`` so that instead of executing a script, it will just
  compile it and return a function handle:

  .. code::

        x = load('myscript.evc');

  To execute it, call ``x()``.  To execute immediately:

  .. code::

        result = (load('myscript.evc'))();

  where ``result`` gets the return value of the executed script, either
  ``null`` or perhaps a handle to an object or object constructor.

  Corrollaries of this change:

  * Need all variables to be on the stack, as if they were in a function,
    rather than be in the global symbol table.

  * Need a ``global`` keyword as a clean way to tell whether we're
    pushing a scope-level variable on the stack or inserting it in
    the global symbol table.  This should be cleaner anyway.

  * ergo need another overhaul of assembler.c

* add something like Python's repr() sooner rather than later,
  it helps with debugging.

* Use autoconf, automake & cet., not just a hand-written Makefile

* Start adding in test scaffolding where possible.

* Figure out how to deal with duplicate or cyclic loads.  It can't just
  be a cache of path names, because the same path can be expressed in
  different ways.

* Fix the cyclic-reference problem in GC.

* MEMORY LEAK BUG:  When top-level expressions have been executed, their
  code arrays should be deleted.  Same for functions' code arrays if
  all references to them leave scope.  However, current GC implementation
  is too naive for this, deleting IIFEs before they can execute.  So for
  now, GC is turned off for all executable code, letting it zombify.

Library/Language Features
-------------------------

* Support the continue statement

* Add sets and tuples

* Add try/catch

* Add a Matrix/DSP module, something like NumPy for Python

* Support regular expressions

* Support complex numbers.

* Add debug module, make frames/code objects visible to user

* Add stdin and shell environment to Io module

* Add a binary version of string type.  It reads literals but does
  not 'interpret' utf-8 encoding or get confused by nulchars in the
  middle of the string.

Mebbe/Wishlist/Low-prio bugs
----------------------------

* vm.c and types/function.c, as well as the structs they manipulate
  (vmframe_t, function_handle_t, executable_t) are very tangled up
  and require awkward back-and-forth calls between the two source
  files, esp. function_prep_frame and function_call.

* Replace jmp_buf in token.c with either fussier management of helper
  functions' return values, or with a big damn get_tok function.

* At assemble_eval() time, determine if certain expressions can be
  reduced to single consts known at assemble time.  Currently something
  like "1 + 2" will result in an operation at execution time instead
  of being compiled to just "3".  Big lift, basically means creating
  a parse tree BEFORE generating code.  We're currently doing these
  two tasks simultaneously.

* Preserve token buffer in interactive mode so that the UP arrow will
  recall previous expressions.

* Figure out how to de-chaos-ify and elegantize multiple inheritance
  without having to add a 'class' syntax.

* String data type encodes Unicode in utf-8, which is compact, but it
  makes for slower processing.  Instead do something like cpython, which
  has an array data-width variable in its meta-data.  C-string
  termination still works, so long as the right uint*_t type is used
  when checking for a value of zero.

.. : vim: set syntax=rst :
