Bugs
----

* BUGs 4/2025:

        * All user-visible data types need a .cpmz method.

Must Do
-------

* Make sure all built-in types have a .cmpz method.

* Make sure all .cmpz methods match documentation.

* Interactive mode problem: token state machine is created and destroyed
  by a wrapping call from assemble().  So if it's interactive mode and
  someone types "a = 1; b = 2;" all on the same line, the first part
  ("a = 1;") will be executed and the second part ("b = 2;") will be
  discarded and never parsed.

* Integers are too recessive now; we need a way to int-ify a float
  without using a slow built-in function.

* ``demos`` folder is a joke.  Write a real suite of demos, split into
  two groups: demos that are indeed demos and present meaningful examples
  of the language; and demos that are either stress-tests or sanity
  tests, which can be run in one go to check things before pushing a
  commit onto the repository.

* ``this`` keyword barely tested; it will probably break a lot of
  stuff that seems to work without it.  Logically it should not work
  in the callback of a .foreach method, at least the way my program
  works at the moment.

* Start adding in test scaffolding where possible.

* Figure out how to deal with duplicate or cyclic loads.  It can't just
  be a cache of path names, because the same path can be expressed in
  different ways.

* Fix the cyclic-reference problem in GC.

Library/Language Features
-------------------------

* Support array slicing

* Add sets

* Support soft keywords

* Add a Matrix/DSP module, something like NumPy for Python

* ^^ also add Tensor module, why not?

* Support regular expressions

* Add debug module, make frames/code objects visible to user

* Add stdin and shell environment to Io module

* Add way to pass arguments to imported scripts, and a way for the
  script to access them.  Maybe a special identifier token like ``$0``.

* Add keyword arguments, esp. useful for things like ``print``.

Mebbe/Wishlist/Low-prio bugs
----------------------------

* (requires parser rewrite) Optimize parsing of complex-number
  expressions like '2 + 2j' so that they evaluate to a single complex
  number at compile time instead of runtime.

* Replace setjmp in assemble.c with normal stack unwinding.  May need
  to replace EOF with OC_EOF so that a <0 check will always mean
  'error'.

* Add way to mark current location while parsing, so that token.c and
  main.c aren't making their own separate and different error splashes.

* vm.c and types/function.c, as well as the structs they manipulate
  (vmframe_t, function_handle_t, executable_t) are very tangled up
  and require awkward back-and-forth calls between the two source
  files, esp. function_prep_frame and function_call.

* Replace jmp_buf in token.c with either fussier management of helper
  functions' return values, or with a big damn get_tok function.

* At assemble_eval() time, determine if certain expressions can be
  reduced to single consts known at assemble time.  Currently something
  like "1 + 2" will result in an operation at execution time instead
  of being compiled to just "3".  Big lift, basically means creating
  a parse tree BEFORE generating code.  We're currently doing these
  two tasks simultaneously.

* Preserve token buffer in interactive mode so that the UP arrow will
  recall previous expressions.

* String data type encodes Unicode in utf-8, which is compact, but it
  makes for slower processing.  Instead do something like cpython, which
  has an array data-width variable in its meta-data.  C-string
  termination still works, so long as the right uint*_t type is used
  when checking for a value of zero.

.. : vim: set syntax=rst :
