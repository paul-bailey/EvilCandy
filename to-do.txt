Bugs
----

* BUGs 4/2025:

        * All user-visible data types need a .cpmz method.
        * ``(range(x)).foreach(y);`` works but ``range(x).foreach(y);``
          does not, though both should behave the same.
        * More of a flaw than a bug, but in TTY mode, 'if' and 'for'
          statements do not execute when the closing brace is received,
          because the parser needs to peek and check if there's an
          'else' statement.  So to execute the statement, a user would
          have to type an additional semicolon or else add the 'else'
          portion.
        * there's a VAR_INCR/DECR_REF imbalance somewhere, preventing
          some vars from getting deleted when they should.

Must Do
-------

* Integers are too recessive now; we need a way to int-ify a float
  without using a slow built-in function.

* ``this`` keyword barely tested; it will probably break a lot of
  stuff that seems to work without it.

* Start adding in test scaffolding where possible.

* Figure out how to deal with duplicate or cyclic loads.  It can't just
  be a cache of path names, because the same path can be expressed in
  different ways.

* Fix the cyclic-reference problem in GC.

Library/Language Features
-------------------------

* Support the continue statement

* Add sets

* Add try/catch

* Support soft keywords

* Support complex numbers.

* Add a Matrix/DSP module, something like NumPy for Python

* ^^ also add Tensor module, why not?

* Support regular expressions

* Add debug module, make frames/code objects visible to user

* Add stdin and shell environment to Io module

Mebbe/Wishlist/Low-prio bugs
----------------------------

* Replace setjmp in assemble.c with normal stack unwinding.  May need
  to replace EOF with OC_EOF so that a <0 check will always mean
  'error'.

* Add way to mark current location while parsing, so that token.c and
  main.c aren't making their own separate and different error splashes.

* To cast an int to a float, user has to do something like
  ``x = 1.0 * x``.  Add something like ``float(x)`` and ``int(x)``
  instead.  Make these be keywords/instructions instead of built-in
  functions, to keep it fast.

* vm.c and types/function.c, as well as the structs they manipulate
  (vmframe_t, function_handle_t, executable_t) are very tangled up
  and require awkward back-and-forth calls between the two source
  files, esp. function_prep_frame and function_call.

* Replace jmp_buf in token.c with either fussier management of helper
  functions' return values, or with a big damn get_tok function.

* At assemble_eval() time, determine if certain expressions can be
  reduced to single consts known at assemble time.  Currently something
  like "1 + 2" will result in an operation at execution time instead
  of being compiled to just "3".  Big lift, basically means creating
  a parse tree BEFORE generating code.  We're currently doing these
  two tasks simultaneously.

* Preserve token buffer in interactive mode so that the UP arrow will
  recall previous expressions.

* Figure out how to de-chaos-ify and elegantize multiple inheritance
  without having to add a 'class' syntax.

* String data type encodes Unicode in utf-8, which is compact, but it
  makes for slower processing.  Instead do something like cpython, which
  has an array data-width variable in its meta-data.  C-string
  termination still works, so long as the right uint*_t type is used
  when checking for a value of zero.

.. : vim: set syntax=rst :
