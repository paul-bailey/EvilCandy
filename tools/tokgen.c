#include "gen.h"
#include <stdio.h>
#include <stdlib.h>

/* XXX: Why so stingy? We're not building this on a Casio */
#define MAX_TOKENS      256
#define MAX_TAGS        128
#define MAX_TAGS_PER_TOK 12

#define MIN_TOKEN_VALUE   1

#define S_AUTOGEN \
 "/*\n" \
 " * Auto-generated by tools/tokgen.\n" \
 " * Do not manually edit.\n" \
 " */\n"

struct token_t {
        char *tokname;
        char *repr;
        int value;
        char *tags[MAX_TAGS_PER_TOK];
        int ntags;
        enum { KEYWORD, DELIMITER, OTHER } kind;
};

/* not even kidding */
struct trie_t {
        struct trie_t **next;
        char *value;
};

static struct trie_t delimtok_trie;
enum {
        /* for trie diving */
        MIN_DELIM       = 32,
        N_TRIES_PER     = 128 - MIN_DELIM,
};

static char *token_tags[MAX_TAGS];
static int token_ntags = 0;
static int token_value = MIN_TOKEN_VALUE;
static struct token_t *tokens[MAX_TOKENS];
static int n_tokens = 0;

static void
insert_delimtrie(char *tokname, char *repr)
{
        struct trie_t *trie = &delimtok_trie;
        int depth = 0;
        while (*repr) {
                struct trie_t *nexttrie;
                int i;

                i = *repr - MIN_DELIM;
                if (i < 0 || i >= N_TRIES_PER) {
                        fprintf(stderr, "Unexpected delim char '%c'\n", *repr);
                        exit(1);
                }

                if (!trie->next) {
                        trie->next = calloc(N_TRIES_PER, sizeof(*trie));
                        if (!trie->next)
                                oom();
                }

                nexttrie = trie->next[i];
                if (!nexttrie) {
                        nexttrie = malloc(sizeof(*nexttrie));
                        if (!nexttrie)
                                oom();
                        memset(nexttrie, 0, sizeof(*nexttrie));
                        trie->next[i] = nexttrie;
                }
                trie = nexttrie;
                repr++;
                depth++;
        }
        if (depth > 3) {
                fprintf(stderr, "suspicious insert, depth=%d\n", depth);
                exit(1);
        }
        if (trie->value) {
                fprintf(stderr, "suspicious insert, value already exists\n");
                exit(1);
        }
        trie->value = tokname;
}

static char *
addtag(char *start, char *end)
{
        char *res;
        size_t len;
        int i;
        if (start == end) {
                fprintf(stderr, "tag of size 0 (ending in ...%s)\n", start);
                exit(1);
        }
        len = end - start;

        for (i = 0; i < token_ntags; i++) {
                if (!memcmp(start, token_tags[i], len)
                    && strlen(token_tags[i]) == len) {
                        return token_tags[i];
                }
        }
        /* still here, adding a new tag */
        res = malloc(len + 1);
        memcpy(res, start, len);
        res[len] = '\0';
        token_tags[token_ntags++] = res;
        return res;
}

static struct token_t *
next_token(FILE *fp)
{
        struct token_t *ret;
        int i, ntok, q;
        int tagidx = 2; /* may be overruled below */
        char *s;

        /* Shut me down! Tokens making tokens! How perverse... */
        char **input = tokenize_next_line(fp, &ntok);
        if (!input)
                return NULL;

        if (ntok == 0) {
                fprintf(stderr, "ntok cannot be 0 (bug)?\n");
                exit(1);
        }
        if (ntok > 3) {
                fprintf(stderr, "malformed input (did you put spaces between tags?)\n");
                exit(1);
        }

        ret = calloc(1, sizeof(*ret));
        if (!ret)
                oom();

        /* Validate token name */
        s = input[0];
        if (!isalpha((int)*s) && *s != '_') {
                fprintf(stderr,
                        "first character of token name '%s' is invalid\n",
                        input[0]);
                exit(1);
        }
        while (*s) {
                if (!isalnum((int)*s) && *s != '_') {
                        fprintf(stderr,
                                "token name '%s' contains invalid characters\n",
                                input[0]);
                }
                s++;
        }

        ret->value = token_value++;
        ret->tokname = strdup(input[0]);
        if (!ret->tokname)
                oom();

        if (ntok == 1) {
                ret->kind = OTHER;
                ret->repr = strdup(input[0]);
                if (!ret->repr)
                        oom();

                goto done;
        }

        /* check representation or tags */
        s = input[1];
        if (*s != '\'' && *s != '"') {
                ret->kind = OTHER;
                ret->repr = strdup(input[0]);
                if (!ret->repr)
                        oom();
                tagidx = 1;
                goto tags;
        }
        q = *s++;
        if (q == '\'')
                ret->kind = DELIMITER;
        else
                ret->kind = KEYWORD;
        while (*s != q && *s != '\0')
                s++;
        if (*s == '\0') {
                fprintf(stderr, "Imbalanced quote %s\n", input[1]);
                exit(1);
        }
        if (s[1] != '\0') {
                fprintf(stderr,
                        "Unexpected characters after quote: %s\n",
                        input[1]);
                exit(1);
        }
        *s = '\0';
        ret->repr = strdup(input[1] + 1);
        if (!ret->repr)
                oom();

        if (ntok == 2)
                goto done;

tags:
        s = input[tagidx];
        for (;;) {
                /* How is strchrnul not universal!? */
                char *next = strchr(s, '|');
                if (!next)
                        next = s + strlen(s);
                ret->tags[ret->ntags++] = addtag(s, next);
                s = next;
                if (*s == '\0')
                        break;
                else /* '|' */
                        s++;
        }

done:

        return ret;
}


static void
get_token_defs(FILE *fp)
{
        struct token_t *tok;
        int i;
        while ((tok = next_token(fp)) != NULL) {
                if (n_tokens >= MAX_TOKENS) {
                        fprintf(stderr, "Too many tokens to define!\n");
                        fprintf(stderr, "Consider raising MAX_TOKENS in tools/tokgen.c\n");
                        exit(1);
                }

                tokens[n_tokens++] = tok;
        }
        if (n_tokens == 0) {
                fprintf(stderr, "Expected: at least one token\n");
                exit(1);
        }

        for (i = 0; i < n_tokens; i++) {
                struct token_t *t = tokens[i];
                if (t->kind != DELIMITER)
                        continue;
                insert_delimtrie(t->tokname, t->repr);
        }
}

static bool
hastag(struct token_t *t, char *tag)
{
        int i;
        for (i = 0; i < t->ntags; i++) {
                if (!strcmp(t->tags[i], tag))
                        return true;
        }
        return false;
}

static void
print_tag_helper(char *tag)
{
        int i, count;

        printf("\nstatic inline bool\n");
        printf("istok_%s(int t)\n{\n", tag);

        printf("\treturn ");
        count = 0;
        for (i = 0; i < n_tokens; i++) {
                struct token_t *t = tokens[i];
                if (hastag(t, tag)) {
                        if (count > 0) {
                                if ((count % 3) == 0)
                                        printf("\n\t");
                                printf(" | ");
                        }
                        count++;
                        printf("t == OC_%s", t->tokname);
                }
        }
        printf(";\n}\n\n");
}

#define TOK_KW_SEEK_PROTO "int token_kw_seek__(const char *key)"
#define TOKEN_NAME_PROTO  "const char *token_name(int t)"
#define TOK_DELIM_SEEK_PROTO "int token_delim_seek__(char *s, int *tok)"

static void
print_enumerations(void)
{
        int i;

        static const char *HEADER = S_AUTOGEN
                                    "#ifndef TOKEN_GEN_H\n"
                                    "#define TOKEN_GEN_H\n\n"
                                    "#include <stdbool.h>\n\n";
        static const char *FOOTER = "#endif /* TOKEN_GEN_H */\n";

        printf("%s", HEADER);

        printf("enum {\n");
        for (i = 0; i < n_tokens; i++) {
                struct token_t *t = tokens[i];
                printf("\tOC_%s = %d,\n", t->tokname, t->value);
        }
        printf("\tOC_NTOK = %d\n", token_value);
        printf("};\n");

        for (i = 0; i < token_ntags; i++) {
                print_tag_helper(token_tags[i]);
        }

        printf("extern %s;\n", TOKEN_NAME_PROTO);
        putchar('\n');
        printf("/* should be used only by token.c */\n");
        printf("extern %s;\n", TOK_KW_SEEK_PROTO);
        printf("extern %s;\n", TOK_DELIM_SEEK_PROTO);

        putchar('\n');
        printf("%s", FOOTER);
}

static void
prtabs(int n)
{
        while (n-- > 0)
                putchar('\t');
}

static void
trie_case(struct trie_t *trie, int c, int depth)
{
        int i;
        if (!trie) {
                fprintf(stderr, "NULL trie, invalid\n");
                exit(1);
        }
        if (depth > 3) {
                fprintf(stderr, "Suspicious trie, depth=%d\n", depth);
                exit(1);
        }

        if (!trie->next) {
                if (trie->value) {
                        prtabs(depth + 1);
                        printf("*tok = OC_%s;\n", trie->value);
                } else {
                        fprintf(stderr, "Suspicious retrieval, hit end without value\n");
                        exit(1);
                }
                prtabs(depth + 1);
                printf("return %d;\n", depth);
                return;
        }

        prtabs(depth + 1);
        printf("switch(s[%d]) {\n", depth);

        for (i = 0; i < N_TRIES_PER; i++) {
                if (!trie->next[i])
                        continue;
                prtabs(depth + 1);
                printf("case '%c':\n", i + MIN_DELIM);
                trie_case(trie->next[i], i + MIN_DELIM, depth + 1);
        }

        prtabs(depth + 1);
        printf("default:\n");
        if (trie->value) {
                prtabs(depth + 2);
                printf("*tok = OC_%s;\n", trie->value);
                prtabs(depth + 2);
                printf("return %d;\n", depth);
        } else {
                prtabs(depth + 2);
                printf("return 0;\n");
        }
        prtabs(depth + 1);
        printf("}\n");
}

static void
print_utils(void)
{
        int i;
        static const char *HEADER =
                S_AUTOGEN
                "\n#include <evilcandy.h>\n"
                "#include <token.h>\n\n";
        static const char *GET_NAMES_FUNC =
                TOKEN_NAME_PROTO "\n"
                "{\n"
                "\tif (t <= 0 || t >= OC_NTOK)\n"
                "\t\treturn NULL;\n"
                "\tbug_on(TOKEN_NAMES[t] == NULL);\n"
                "\treturn TOKEN_NAMES[t];\n"
                "}\n";
        static const char *KW_SEEK_TOP =
                "/* should be used only by token.c */\n"
                TOK_KW_SEEK_PROTO "\n"
                "{\n"
                "\tstatic const struct kw_tbl_t {\n"
                "\t\tconst char *name;\n"
                "\t\tint v;\n"
                "\t} KEYWORDS[] = {\n";
        static const char *KW_SEEK_BOTTOM =
                "\t\t{ NULL, 0 }\n"
                "\t};\n"
                "\tconst struct kw_tbl_t *tkw;\n"
                "\tfor (tkw = KEYWORDS; tkw->name != NULL; tkw++) {\n"
                "\t\tif (!strcmp(tkw->name, key))\n"
                "\t\t\treturn tkw->v;\n"
                "\t}\n"
                "\treturn -1;\n"
                "}\n\n";

        printf("%s", HEADER);
        printf("static const char *TOKEN_NAMES[OC_NTOK] = {\n");
        for (i = 0; i < n_tokens; i++) {
                struct token_t *t = tokens[i];
                printf("\t[OC_%s] = \"%s\",\n", t->tokname, t->repr);
        }
        printf("};\n");

        printf("\n%s\n", GET_NAMES_FUNC);

        printf("%s", KW_SEEK_TOP);
        for (i = 0; i < n_tokens; i++) {
                struct token_t *t = tokens[i];
                if (t->kind != KEYWORD)
                        continue;
                printf("\t\t{ \"%s\",\tOC_%s },\n",
                       t->repr, t->tokname);
        }
        printf("%s", KW_SEEK_BOTTOM);

        if (delimtok_trie.next == NULL)
                return;

        printf(TOK_DELIM_SEEK_PROTO "\n{\n");
        trie_case(&delimtok_trie, 0, 0);
        printf("}\n\n");
}

int
main(int argc, char **argv)
{
        char *opt;
        if (argc != 2) {
                fprintf(stderr, "Expected: target\n");
                exit(1);
        }
        opt = argv[1];

        get_token_defs(stdin);

        if (!strcmp(opt, "enum")) {
                print_enumerations();
        } else if (!strcmp(opt, "util")) {
                print_utils();
        } else {
                fprintf(stderr, "Expected targets: enum|util\n");
                exit(1);
        }
        return 0;
}

